using seed 522 with uniform or count chain prioritizer makes ModuleBioAssay2 fail!

dropelt aware merge droplet may need to merge vertically or horizontally. It may not be possible to make one droplet move up and the other left due to tension. Test on platform
for now we assume we can.

400 x 400 grid can run at 60fps on my laptop.


Module-based:
	allocation (of library modules)
	binding	   (operations to modules)
	schedule   (operation execution)
	placement  (of modules)
	routing

### My BioAssay JSON Example ###

{
	"name"  : "PCR",
	"1" : {
		"type" : "input",
		"substance" : "water"
	},
	"2" : {
		"type" : "input",
		"substance" : "alcohol"
	},
	"3" : {
		"type" : "mix",
		"input" : [ "1" ,  "2" ]
	},
	"4" : {
		"type" : "output",
		"input" : [ "3" ]
	}
}

### My Library Example ###

{
	"name" : "a lib",
	{
		"name" : "heater",
		"configs" : [
			{
				"width" : "4",
				"height" : "3",
				"duration" : "22"
			},
			{
				"width" : "4",
				"height" : "4",
				"duration" : "14"
			},
		]
	},
	{
		"name" : "X detector",
		"configs" : [
			{
				"width" : "2",
				"height" : "2",
				"duration" : "4" 
			}
		]
	},  
}


















Droplet:
	at



findNextActions():
	for operation in operations:
		# queueAction()
		if operation.type == "merge":
			d1 = operation.d1
			d2 = operation.d2
			
			moves = []
			for move in maybeMoves:
				next1 = d1.at + move
				
				for do in droplets:
					if !okStatic(d1, do) | !okDynamic(d1, do):
						continue move
			
				moves.add(move)	
				
			

snap():
	for action in actions:
		# execute(operation)
		

compute():
	findNextActions()
	snap()

	
	
	
    for (Agent agent : memory.agents) {
  Point at;
  
  int lastCommittedIndex = agent.path.size() - 1;
  if (timestep <= lastCommittedIndex) {
    at = agent.path.get(timestep);  // current committed move
  } else {
    // @TODO: agents can have more than 1 plan if they are extensions. 
    Plan plan = memory.getPlan(agent);
    if (plan == null) {
      //at = agent.path.get(lastCommittedIndex); // no plan? use the last known committed move

      // Agents without any committed move at this time-step or any plan, we can request to move. 
      // These are the "conflicting agents" which will try to resolve the newer deadlock.
      continue; 

    } else {  // planned moves
      int offset = lastCommittedIndex;
      int index = timestep - offset;
      
      int lastPlannedIndex = plan.path.size() - 1;
      if (index <= lastPlannedIndex) {
        at = plan.path.get(index);  // current plan move
      } else {
        // @TODO: shouldn't past planning also be the guys which can move?
        //at = plan.path.get(lastPlannedIndex); // past final move in plan? use the last known planned move.
        continue;
      }
    }
  }
  
  int id = agent.getId();
  occupied[at.x][at.y] = id;
}